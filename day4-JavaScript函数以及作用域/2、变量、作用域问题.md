# 2、变量中 基本类型和引用类型的值

	## 	JavaScript 包含两种不同类型的值： 基本类型值 和 引用类型值。 基本类型值指的是简单的数据段，而引用类型值指的是可以由多个值构成的 对象 。

## 	当一个值赋给变量时，解析器必须确定这个值是 普通类型 还是引用类型，前面说了基本类型有：Undefined、Null、Number、Boolean、String以及 新增的Symbol 和 BigInt。这些类型是按值访问的，操作的是在变量中保存的实际的值；

## 	引用类型：变量的值如果是一个引用类型（对象），变量存的就是这个对象的引用地址了，在操作对象时，你操作的不是存在堆内存中这个对象，而操作的对象的引用。

```javascript
// 注：当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。
```

## 复制变量值：

### 【1】基本类型复制变量值，会在变量对象上创建一个新值，然后把这个新值复制到新变量位置上，比如说：

```javascript
var num1 = 5;
var num2 = num1;
console.log(num1 === num2) // true
console.log(num1, num2) // 5 5
// 改变num2的值
num2 = 10;
console.log(num1, num2) // 5 10
console.log(num1 === num2) // false
//  我们使用 num1 的值来初始化 num2 的值，让 num2 的值等于 num1 的值，但是因为他们上基本数据类型，所以他们的值是相互独立的，当我修改了 num2的值之后， num1的值不会改变，所以 这时候num1 和 num2 是不相等的
```

### 【2】当一个变量复制引用类型的值时，同样也会将储存在变量对象中的值复制一份，放到新变量所分配的位置上，但是现在这个值是一个对象的引用地址，是一个指针，它指向的是存在堆内存里的对象，这时候如果对象里面的值发生了改变，但是对于变量来说，它的值并没有变，因为它所存的值，那个指针还是指向原来的对象，对象里的值变了对它没有影响，比如说：

```javascript
var obj1 = {name: "熊大"};
var obj2 = obj1;
// 这时候 obj1 和 obj2 的值都是 {name: "熊大"} 这个对象的引用地址，obj1 和 obj2 这时候是相等的
console.log(obj2 === obj1) // true
console.log(obj1, obj2) // {name: "熊大"} {name: "熊大"}

// 这时候我改变 obj2 里面的name属性
obj2.name = "大明";
console.log(obj1, obj2) //{name: "大明"} {name: "大明"}
// 对象中的值发生了改变，但是对于 obj1 和 obj2 来说，他们存的对象的指针并没有发生改变，所以他们还是相等的
console.log(obj2 === obj1) // true
```

### 【3】函数传参时 基本类型和 引用类型的区别：

### 		JavaScript中函数传递参数也是按值传递的，就是说你向函数传递了一个参数，就相当于在函数内部定义了一个新的局部的变量，然后将传递过来的值复制一份，再赋值给新定义的这个变量，所以同理，当定义了一个值为普通类型的变量，把这个变量当做参数传递给函数后，函数内部对这个参数作出修改，外部定义的这个变量不会发生改变； 

### 	而引用类型传递的是一个引用地址，函数内部对参数中的值进行修改时，变量中存的变量会发生改变；

```javascript
var str = "Hello World"; // 定义一个存着普通类型值的变量
function handleChange (value) {
  value = "bal bal"
}
handleChange(str)
cosnole.log(str) // Hello World
```

```javascript
var obj = { name: "熊大" }; // 定义一个存着引用类型值的变量
function handleChange (value) {
  value.name = "大熊熊"
}
handleChange(obj)
cosnole.log(obj) // { name: "大熊熊" }
```

**练习**
    1、编写一个函数，计算n ~ m之间的闰年（传参实现）    

​	2、函数实现1-100中7的倍数或者带7的数（逢任何数字（通过传参）过）   

​	3、编写函数判断任意一个数是否是素数

# 3、作用域：变量的作用范围

## 【1】全局环境：在JavaScript中，全局环境被认为是window对象，因此，所有的全局变量和全局函数都是作为window对象的属性和方法创建的， 全局环境是最外围的一个执行环境，全局定义的变量或者函数，只有把应用程序退出才会被销毁（比如说关闭浏览器）

```javascript
// 直接在script标签中定义的变量就是全局变量
// 在函数体内，不使用var定义的变量，也是全局变量，不使用var定义，相当于是使用window定义的
function test() {
  a = 1 // window.a = 1
}
test();
console.log(a) // 1
```

## 【2】局部环境：每一个函数都有自己的执行环境，在函数内部定义的变量，只有在函数内部可以使用，在函数外部是使用不了的，如果想使用这个变量的值，可以用个return 把值返回到函数外部，或者赋值给一个外部变量。

```javascript
function test() {
  var a = 1 // 局部变量
}
test();
console.log(a) // ReferenceError: a is not defined 
```

## 【3】作用域链：当代码在一个环境中执行时，会创建变量对象的一个作用域链。 作用域链的用途，是保证对执行环境中所有的变量和函数有序访问，作用域链中的变量的下一个变量对象来自外部环境，而再下一个变量对象则来自于下一个外部环境，一直延续到全局环境，全局环境的变量对象是作用域链的最后一个对象。

# 4、堆栈：是一种数据结构，指的是数据存取的方式，当定义一个变量时，内存会开辟一段空间 ；

## 		栈（ Stack）：先进后出（FILO），在栈顶做插入（压栈）和删除操作（出栈）。

			## 		队列：先进先出（FIFO），在队头做删除操作,在队尾做插入操作。

## 		堆和它们不同，代码执行时系统动态分配，不存在是先进后出还是先进先出。

## 		执行环境执行栈（也称执行上下文–execution context）:当JavaScript解释器初始化执行代码时，它首先默认进入全局执行环境，从此刻开始，**函数的每次调用都会创建一个新的执行环境，每一个执行环境都会创建一个新的环境对象压入栈中**。     当执行流进入一个函数时，函数的环境对象就会被压入一个环境栈中（execution stack）。在函数执行完后，栈将其环境弹出，把控制权返回给之前的执行环境。

# 5、递归：程序调用自身的编程技巧称为递归（ recursion）。

```javascript
递归，就是在运行的过程中调用自己，本质就是循环。

构成递归需具备的条件
    1. 子问题须与原始问题为同样的事，且更为简单；
    2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。

由于递归是函数本身一层一层压栈，导致先入栈的不能出栈，空间占满以后就会造成堆栈溢出
// 
斐波那契数列指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89........

这个数列从第3项开始，每一项都等于前两项之和。

在数学上，斐波纳契数列以如下被以递归的方法定义：F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n>2，n∈N*）
```





练习
1、利用递归求100的阶乘2、编写函数计算任意数字的阶乘（两种方法）3、函数和循环结合打印任意乘法表4、编写函数实现：两个数平方的阶乘相加的和     要求：三个函数实现，一个求阶乘，一个求平方，第三个函数利用这两个函数求出最终结果5、如果一个数恰好等于它的因数（除自身以外）之和，则称该数为“完全数” perfect number。     请列出m~n（m<n）的所有完全数（要求用两个函数实现）



